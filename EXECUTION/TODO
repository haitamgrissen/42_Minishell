//add search envs by keys :: DONE
//search envs and adding new node if key not found add new node  if found update value :: DONE
//unset (remove node by key) :: DONE
//check exported key (must with alphabetic chars and must contain only laphanumeric chars) :: Done

   
// manage leaks (free olds) :: Done so far

// to do refactor code in env_var.c

Built-ins

    ◦ pwd with no options :: DONE
    ◦ echo with option -n :: DONE
    ◦ cd with only a relative or absolute path :: DONE ///add perror
    ◦ export with no options :: DONE
    ◦ unset with no options :: DONE
    ◦ env with no options or arguments :: DONE
    
◦ exit with no options







USEFUL LINKS ::
pipes implemntatiion :
    http://www.cs.loyola.edu/~jglenn/702/S2005/Examples/dup2.html


PIPES IMPLEMNTATIION :::::::

i = -1;
pid_t pid;
int *pipesfd = malloc(sizeof(int) * (nbcommands - 1) * 2);

while (++i < nbcommands - 1)
{
    pipe(pipesfd + 2 * i);
}

while (++i < nbcommands)
{
    pid = fork();
    if (pid == 0)
    {
		dup2(fd[2 * i], 0);
        child_process(..., i);
    }
	else 
		waitpid(pid);
}

close(fddyal lpipe)




execve

char	*get_working_path(char	*command)
{
	char	*str;
	char	**paths;
	struct stat  buf;
	int		ret;
	
	
	paths = get_paths();
	int i = 0;
	while (paths[i])
	{
		str = ft_strdup(paths[i]);
		str = ft_strjoin(str, ft_strdup("/"));
		str = ft_strjoin(str, ft_strdup(command));
		stat(str, &buf);
		mode_t mode = buf.st_mode;
			//printf("mode : %d\nstr : %s\n", mode & S_IXUSR, str);
		if ((ret = open(str, O_RDONLY)) != -1)
		{
			return (str);
		}
		bzero(&buf, sizeof(buf));
		i++;
	}
	str = ft_strdup(command);
	stat(str, &buf);
	mode_t mode = buf.st_mode;
	if ((ret = open(str, O_RDONLY)) != -1)
	{
			printf("%s\n", str);
			return str;
	}
	if (mode & S_IXUSR)
	{
		printf("mode : %d\nstr : %s\n", mode & S_IXUSR, str);
		return (str);
	}
	else
	{
		printf("makina ta9lwa\n");
		return (NULL);
	}
}


working Pipe but too long for norminette

int	execute_pipe(t_cmd *cmd)
{
	int		pid;
	int		pipe_[2];
	int		p_out;
	int		p_in;
	int		status;
	t_cmd	*current;

	p_in = 0;
	p_out = 1;
	current = cmd;
	while (current->next != NULL)
	{
		pipe(pipe_);
		p_out = pipe_[1];
		pid = fork();
		if (pid == 0)
		{
			dup2(p_out, 1);
			close(pipe_[1]);
			dup2(p_in, 0);
			close(pipe_[0]);
			execute_cmd(current);
		}
		if (p_in > 2)
			close(p_in);
		p_in = pipe_[0];
		close(p_out);
		current = current->next;
	}
	pid = fork();
	if (pid == 0)
	{
		dup2(p_in, 0);
		close(p_in);
		close(pipe_[1]);
		execute_cmd(current);
	}
	close(pipe_[1]);
	close(p_in);
	while (waitpid(-1, &status, 0) > 0)
		;
	return (0);
}




////last one

int	execute_pipe(t_cmd *cmd)
{
	int		pid;
	int		pipe_[2];
	int		p_out;
	int		p_in;
	int		status;
	t_cmd	*current;

	p_in = 0;
	p_out = 1;
	current = cmd;
	
	
	while (current->next != NULL)
	{
		pipe(pipe_);
		p_out = pipe_[1];
		pid = fork();
		if (pid == 0)
		{
			dup2(p_out, 1);
			close(pipe_[1]);
			dup2(p_in, 0);
			close(pipe_[0]);
			execute_cmd(current);
		}
		if (p_in > 2)
			close(p_in);
		p_in = pipe_[0];
		close(p_out);
		current = current->next;
	}
	pid = fork();
	if (pid == 0)
	{
		dup2(p_in, 0);
		if(p_in != 0)
			close(p_in);
		execute_cmd(current);
	}
	if(pipe_[1] != 1)
		close(pipe_[1]);
	if(p_in != 0)
		close(p_in);
	while (waitpid(-1, &status, 0) > 0)
		;
	return (0);
}