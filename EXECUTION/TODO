//add search envs by keys :: DONE
//search envs and adding new node if key not found add new node  if found update value :: DONE
//unset (remove node by key) :: DONE
//check exported key (must with alphabetic chars and must contain only laphanumeric chars) :: Done

   
// manage leaks (free olds) :: Done so far

// to do refactor code in env_var.c

Built-ins

    ◦ pwd with no options :: DONE
    ◦ echo with option -n :: DONE
    ◦ cd with only a relative or absolute path :: DONE ///add perror
    ◦ export with no options :: DONE
    ◦ unset with no options :: DONE
    ◦ env with no options or arguments :: DONE
    
◦ exit with no options







USEFUL LINKS ::
pipes implemntatiion :
    http://www.cs.loyola.edu/~jglenn/702/S2005/Examples/dup2.html


PIPES IMPLEMNTATIION :::::::

i = -1;
pid_t pid;
int *pipesfd = malloc(sizeof(int) * (nbcommands - 1) * 2);

while (++i < nbcommands - 1)
{
    pipe(pipesfd + 2 * i);
}

while (++i < nbcommands)
{
    pid = fork();
    if (pid == 0)
    {
		dup2(fd[2 * i], 0);
        child_process(..., i);
    }
	else 
		waitpid(pid);
}

close(fddyal lpipe)




execve

char	*get_working_path(char	*command)
{
	char	*str;
	char	**paths;
	struct stat  buf;
	int		ret;
	
	
	paths = get_paths();
	int i = 0;
	while (paths[i])
	{
		str = ft_strdup(paths[i]);
		str = ft_strjoin(str, ft_strdup("/"));
		str = ft_strjoin(str, ft_strdup(command));
		stat(str, &buf);
		mode_t mode = buf.st_mode;
			//printf("mode : %d\nstr : %s\n", mode & S_IXUSR, str);
		if ((ret = open(str, O_RDONLY)) != -1)
		{
			return (str);
		}
		bzero(&buf, sizeof(buf));
		i++;
	}
	str = ft_strdup(command);
	stat(str, &buf);
	mode_t mode = buf.st_mode;
	if ((ret = open(str, O_RDONLY)) != -1)
	{
			printf("%s\n", str);
			return str;
	}
	if (mode & S_IXUSR)
	{
		printf("mode : %d\nstr : %s\n", mode & S_IXUSR, str);
		return (str);
	}
	else
	{
		printf("makina ta9lwa\n");
		return (NULL);
	}
}